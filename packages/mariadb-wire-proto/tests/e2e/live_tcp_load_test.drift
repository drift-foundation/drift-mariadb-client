module mariadb.wire.proto.tests.e2e.live_tcp_load_test

import std.core as core;
import std.io as io;
import std.net as net;
import std.concurrent as conc;
import std.containers as containers;
import std.crypto as crypto;
import mariadb.wire.proto.types as types;
import mariadb.wire.proto.packet.header as packet_header;
import mariadb.wire.proto.handshake.hello as hello;
import mariadb.wire.proto.handshake.auth as auth;
import mariadb.wire.proto.command.com_query as com_query;
import mariadb.wire.proto.decode.ok_packet as ok_packet;
import mariadb.wire.proto.decode.resultset as resultset;

type VtInt = conc.VirtualThread<Int>;

const LIVE_HOST: String = "127.0.0.1";
const LIVE_PORT: Int = 34114;
const LIVE_USER: String = "root";
const LIVE_PASSWORD: String = "rootpw";
const LIVE_DB: String = "appdb";
const LIVE_CHARSET: Byte = 45;
const LIVE_TIMEOUT_MS: Int = 3000;
const LIVE_CLIENT_CAPS_INT: Int = 11510412;
const WORKERS: Int = 32;
const QUERIES_PER_WORKER: Int = 100;

fn _timeout() nothrow -> conc.Duration {
	return conc.Duration(millis = LIVE_TIMEOUT_MS);
}

fn _append_bytes(dst: &mut Array<Byte>, src: &Array<Byte>) nothrow -> Void {
	var i = 0;
	while i < src.len {
		dst.push(src[i]);
		i = i + 1;
	}
}

fn _string_bytes(s: &String) nothrow -> Array<Byte> {
	var out: Array<Byte> = [];
	var i = 0;
	val n = s.byte_length();
	while i < n {
		out.push(core.string_byte_at(s, i));
		i = i + 1;
	}
	return move out;
}

fn _read_exact(stream: &net.TcpStream, n: Int) nothrow -> core.Result<Array<Byte>, Int> {
	var out: Array<Byte> = [];
	while out.len < n {
		val rem = n - out.len;
		var buf = io.buffer(rem);
		match stream.read(&mut buf, _timeout()) {
			core.Result::Ok(nread) => {
				val got = nread;
				if got <= 0 { return core.Result::Err(1000); }
				var i = 0;
				while i < got {
					val b: Byte = io.buffer_read(&mut buf, i);
					out.push(b);
					i = i + 1;
				}
			},
			core.Result::Err(_) => { return core.Result::Err(1001); }
		}
	}
	return core.Result::Ok(move out);
}

fn _write_all(stream: &net.TcpStream, bytes: &Array<Byte>) nothrow -> core.Result<Void, Int> {
	var off = 0;
	while off < bytes.len {
		val rem = bytes.len - off;
		var chunk = io.buffer(rem);
		var i = 0;
		while i < rem {
			io.buffer_write(&mut chunk, i, bytes[off + i]);
			i = i + 1;
		}
		match stream.write(&chunk, _timeout()) {
			core.Result::Ok(w) => {
				if w <= 0 { return core.Result::Err(1010); }
				off = off + w;
			},
			core.Result::Err(_) => { return core.Result::Err(1011); }
		}
	}
	return core.Result::Ok(core.void_value());
}

fn _read_packet_payload(stream: &net.TcpStream) nothrow -> core.Result<Array<Byte>, Int> {
	var hdr_bytes: Array<Byte> = [];
	match _read_exact(stream, 4) {
		core.Result::Ok(v) => { hdr_bytes = move v; },
		core.Result::Err(code) => { return core.Result::Err(code); }
	}
	var hdr = types.PacketHeader(payload_len = 0, sequence_id = cast<Byte>(0));
	match packet_header.decode_packet_header(&hdr_bytes) {
		core.Result::Ok(v) => { hdr = move v; },
		core.Result::Err(_) => { return core.Result::Err(1020); }
	}
	if hdr.payload_len < 0 { return core.Result::Err(1021); }
	match _read_exact(stream, hdr.payload_len) {
		core.Result::Ok(payload) => { return core.Result::Ok(move payload); },
		core.Result::Err(code) => { return core.Result::Err(code); }
	}
}

fn _write_packet(stream: &net.TcpStream, payload: &Array<Byte>, seq: Byte) nothrow -> core.Result<Void, Int> {
	var hdr: Array<Byte> = [];
	match packet_header.encode_packet_header(payload.len, seq) {
		core.Result::Ok(v) => { hdr = move v; },
		core.Result::Err(_) => { return core.Result::Err(1030); }
	}
	var packet: Array<Byte> = [];
	_append_bytes(&mut packet, &hdr);
	_append_bytes(&mut packet, payload);
	return _write_all(stream, &packet);
}

fn _sha1_native_password_token(password: &String, scramble: &Array<Byte>) nothrow -> Array<Byte> {
	val pw = _string_bytes(password);
	val stage1 = crypto.sha1(&pw);
	val stage2 = crypto.sha1(&stage1);
	var seeded_input: Array<Byte> = [];
	var i = 0;
	while i < 20 and i < scramble.len {
		seeded_input.push(scramble[i]);
		i = i + 1;
	}
	_append_bytes(&mut seeded_input, &stage2);
	val seeded = crypto.sha1(&seeded_input);
	var out: Array<Byte> = [];
	i = 0;
	while i < stage1.len and i < seeded.len {
		val x = cast<Uint>(stage1[i]) ^ cast<Uint>(seeded[i]);
		out.push(cast<Byte>(x));
		i = i + 1;
	}
	return move out;
}

fn _connect() nothrow -> core.Result<net.TcpStream, Int> {
	val addr = net.socket_addr(LIVE_HOST, LIVE_PORT);
	match net.connect(&addr, _timeout()) {
		core.Result::Ok(s) => { return core.Result::Ok(move s); },
		core.Result::Err(_) => { return core.Result::Err(1100); }
	}
}

fn _read_hello(stream: &net.TcpStream) nothrow -> core.Result<types.HandshakeHello, Int> {
	var payload: Array<Byte> = [];
	match _read_packet_payload(stream) {
		core.Result::Ok(v) => { payload = move v; },
		core.Result::Err(code) => { return core.Result::Err(code); }
	}
	match hello.decode_handshake_hello(&payload) {
		core.Result::Ok(v) => { return core.Result::Ok(move v); },
		core.Result::Err(_) => { return core.Result::Err(1110); }
	}
}

fn _empty_hello() nothrow -> types.HandshakeHello {
	var empty_auth_data: Array<Byte> = [];
	return types.HandshakeHello(protocol_version = cast<Byte>(0), server_version = "", connection_id = cast<Uint>(0), capabilities = cast<Uint>(0), character_set = cast<Byte>(0), status_flags = cast<Uint>(0), auth_plugin_data = move empty_auth_data, auth_plugin_name = "");
}

fn _auth(stream: &net.TcpStream, h: &types.HandshakeHello) nothrow -> core.Result<Void, Int> {
	val token = _sha1_native_password_token(&LIVE_PASSWORD, &h.auth_plugin_data);
	val req = types.HandshakeResponse41(capabilities = cast<Uint>(LIVE_CLIENT_CAPS_INT), max_packet_size = cast<Uint>(16777216), character_set = LIVE_CHARSET, username = LIVE_USER, auth_response = move token, database = LIVE_DB, auth_plugin_name = h.auth_plugin_name);
	var auth_payload: Array<Byte> = [];
	match auth.encode_handshake_response41(&req) {
		core.Result::Ok(v) => { auth_payload = move v; },
		core.Result::Err(_) => { return core.Result::Err(1120); }
	}
	match _write_packet(stream, &auth_payload, cast<Byte>(1)) {
		core.Result::Ok(_) => {},
		core.Result::Err(code) => { return core.Result::Err(code); }
	}
	var server_first: Array<Byte> = [];
	match _read_packet_payload(stream) {
		core.Result::Ok(v) => { server_first = move v; },
		core.Result::Err(code) => { return core.Result::Err(code); }
	}
	match resultset.discriminate_first_response(&server_first) {
		core.Result::Ok(route) => {
			match route {
				resultset.FirstResponseRoute::OkPacket => {
					match ok_packet.decode_ok_packet(&server_first) {
						core.Result::Ok(_) => { return core.Result::Ok(core.void_value()); },
						core.Result::Err(_) => { return core.Result::Err(1130); }
					}
				},
				default => { return core.Result::Err(1131); }
			}
		},
		core.Result::Err(_) => { return core.Result::Err(1132); }
	}
}

fn _query_expect_ok(stream: &net.TcpStream) nothrow -> Int {
	var payload: Array<Byte> = [];
	match com_query.encode_com_query_payload(&"DO 1") {
		core.Result::Ok(v) => { payload = move v; },
		core.Result::Err(_) => { return 1200; }
	}
	match _write_packet(stream, &payload, cast<Byte>(0)) {
		core.Result::Ok(_) => {},
		core.Result::Err(code) => { return code; }
	}
	var first: Array<Byte> = [];
	match _read_packet_payload(stream) {
		core.Result::Ok(v) => { first = move v; },
		core.Result::Err(code) => { return code; }
	}
	match resultset.discriminate_first_response(&first) {
		core.Result::Ok(route) => {
			match route {
				resultset.FirstResponseRoute::OkPacket => {},
				default => { return 1201; }
			}
		},
		core.Result::Err(_) => { return 1202; }
	}
	match ok_packet.decode_ok_packet(&first) {
		core.Result::Ok(_) => { return 0; },
		core.Result::Err(_) => { return 1203; }
	}
}

fn worker_run(worker_id: Int) nothrow -> Int {
	match _connect() {
		core.Result::Ok(s) => {
			var stream = move s;
			var h = _empty_hello();
			match _read_hello(&stream) {
				core.Result::Ok(v) => { h = move v; },
				core.Result::Err(code) => { val _ = stream.close(_timeout()); return 200000 + worker_id * 100 + code; }
			}
			match _auth(&stream, &h) {
				core.Result::Ok(_) => {},
				core.Result::Err(code) => { val _ = stream.close(_timeout()); return 200000 + worker_id * 100 + code; }
			}
			var i = 0;
			while i < QUERIES_PER_WORKER {
				val rc: Int = _query_expect_ok(&stream);
				if rc != 0 {
					val _ = stream.close(_timeout());
					return 300000 + worker_id * 100 + rc;
				}
				i = i + 1;
			}
			val _ = stream.close(_timeout());
			return 0;
		},
		core.Result::Err(code) => { return 100000 + worker_id * 100 + code; }
	}
}

fn _run_all() nothrow -> Int {
	var dq = containers.deque<type VtInt>();
	var i = 0;
	while i < WORKERS {
		val worker = i;
		val t = conc.spawn(| | captures(copy worker) => {
			return worker_run(worker);
		});
		dq.push_back(move t);
		i = i + 1;
	}
	while dq.len() > 0 {
		match dq.pop_front() {
			Some(v) => {
				var t = move v;
				match t.join() {
					core.Result::Ok(code) => {
						if code != 0 { return code; }
					},
					core.Result::Err(_) => { return 400002; }
				}
			},
			None => { return 400001; }
		}
	}
	return 0;
}

fn main() nothrow -> Int {
	return _run_all();
}
