module mariadb.wire.proto.decode.ok_packet

import std.core as core;
import mariadb.wire.proto.errors as errors;
import mariadb.wire.proto.types as types;
import mariadb.wire.proto.packet.lenenc as lenenc;

export {
	OK_PACKET_HEADER,
	decode_ok_packet
};

pub const OK_PACKET_HEADER: Byte = 0;

fn _error(tag: String, offset: Int) nothrow -> errors.PacketDecodeError {
	return errors.PacketDecodeError(tag = tag, offset = offset);
}

fn _read_u16le(input: &Array<Byte>, offset: Int) nothrow -> Uint {
	return cast<Uint>(input[offset]) + cast<Uint>(input[offset + 1]) * cast<Uint>(256);
}

pub fn decode_ok_packet(payload: &Array<Byte>) nothrow -> core.Result<types.OkPacket, errors.PacketDecodeError> {
	if payload.len < 1 {
		return core.Result::Err(_error(errors.TAG_SHORT_OK_PACKET, 0));
	}
	if payload[0] != OK_PACKET_HEADER {
		return core.Result::Err(_error(errors.TAG_INVALID_OK_HEADER, 0));
	}
	val affected_res = lenenc.decode_lenenc_int_at(payload, 1);
	var affected = lenenc.LenEncIntDecoded(value = cast<Uint>(0), next_offset = 0);
	match affected_res {
		Ok(v) => { affected = move v; },
		Err(e) => { return core.Result::Err(e); }
	}
	val last_id_res = lenenc.decode_lenenc_int_at(payload, affected.next_offset);
	var last_id = lenenc.LenEncIntDecoded(value = cast<Uint>(0), next_offset = 0);
	match last_id_res {
		Ok(v) => { last_id = move v; },
		Err(e) => { return core.Result::Err(e); }
	}
	if last_id.next_offset + 4 > payload.len {
		return core.Result::Err(_error(errors.TAG_OK_MISSING_STATUS_OR_WARNINGS, last_id.next_offset));
	}
	val status = _read_u16le(payload, last_id.next_offset);
	val warnings = _read_u16le(payload, last_id.next_offset + 2);
	return core.Result::Ok(types.OkPacket(affected_rows = affected.value, last_insert_id = last_id.value, status_flags = status, warnings = warnings));
}
