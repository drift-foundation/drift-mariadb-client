module mariadb.wire.proto.decode.resultset

import std.core as core;
import mariadb.wire.proto.errors as errors;
import mariadb.wire.proto.types as types;
import mariadb.wire.proto.packet.lenenc as lenenc;

export {
	FirstResponseRoute,
	FIRST_RESPONSE_OK_HEADER,
	FIRST_RESPONSE_ERR_HEADER,
	FIRST_RESPONSE_LOCAL_INFILE_HEADER,
	RESULTSET_NULL_HEADER,
	RESULTSET_EOF_TERMINATOR_HEADER,
	discriminate_first_response,
	decode_text_resultset_packets
};

pub variant FirstResponseRoute {
	OkPacket,
	ErrPacket,
	ResultSet
}

pub const FIRST_RESPONSE_OK_HEADER: Byte = 0;
pub const FIRST_RESPONSE_ERR_HEADER: Byte = 255;
pub const FIRST_RESPONSE_LOCAL_INFILE_HEADER: Byte = 251;
pub const RESULTSET_NULL_HEADER: Byte = 251;
pub const RESULTSET_EOF_TERMINATOR_HEADER: Byte = 254;
pub const RESULTSET_METADATA_FOLLOWS_FALSE: Byte = 0;
pub const RESULTSET_METADATA_FOLLOWS_TRUE: Byte = 1;

type ResultSetCell = types.ResultSetCell;

fn _error(tag: String, offset: Int) nothrow -> errors.PacketDecodeError {
	return errors.PacketDecodeError(tag = tag, offset = offset);
}

pub fn discriminate_first_response(payload: &Array<Byte>) nothrow -> core.Result<FirstResponseRoute, errors.PacketDecodeError> {
	if payload.len < 1 {
		return core.Result::Err(_error(errors.TAG_SHORT_RESPONSE_PAYLOAD, 0));
	}
	val header = payload[0];
	if header == FIRST_RESPONSE_OK_HEADER {
		return core.Result::Ok(FirstResponseRoute::OkPacket());
	}
	if header == FIRST_RESPONSE_ERR_HEADER {
		return core.Result::Ok(FirstResponseRoute::ErrPacket());
	}
	if header == FIRST_RESPONSE_LOCAL_INFILE_HEADER {
		return core.Result::Err(_error(errors.TAG_UNSUPPORTED_LOCAL_INFILE, 0));
	}
	return core.Result::Ok(FirstResponseRoute::ResultSet());
}

fn _is_eof_terminator_packet(payload: &Array<Byte>) nothrow -> Bool {
	return payload.len > 0 and payload[0] == RESULTSET_EOF_TERMINATOR_HEADER and payload.len < 9;
}

fn _decode_text_row(payload: &Array<Byte>, column_count: Int) nothrow -> core.Result<Array<ResultSetCell>, errors.PacketDecodeError> {
	var row: Array<ResultSetCell> = [];
	var idx = 0;
	var col = 0;
	while col < column_count {
		if idx >= payload.len {
			return core.Result::Err(_error(errors.TAG_RESULTSET_ROW_TRUNCATED, idx));
		}
		if payload[idx] == RESULTSET_NULL_HEADER {
			row.push(ResultSetCell::Null());
			idx = idx + 1;
			col = col + 1;
			continue;
		}
		match lenenc.decode_lenenc_string_at(payload, idx) {
			core.Result::Ok(v) => {
				row.push(ResultSetCell::Text(v.value));
				idx = v.next_offset;
				col = col + 1;
			},
			core.Result::Err(e) => { return core.Result::Err(e); }
		}
	}
	if idx != payload.len {
		return core.Result::Err(_error(errors.TAG_RESULTSET_ROW_TRAILING_BYTES, idx));
	}
	return core.Result::Ok(move row);
}

pub fn decode_text_resultset_packets(packets: &Array<Array<Byte>>) nothrow -> core.Result<types.ResultSetDecoded, errors.PacketDecodeError> {
	if packets.len < 1 {
		return core.Result::Err(_error(errors.TAG_RESULTSET_MISSING_COLUMN_COUNT, 0));
	}
	val first_packet = &packets[0];
	val col_count_res = lenenc.decode_lenenc_int_at(first_packet, 0);
	var col_count_dec = lenenc.LenEncIntDecoded(value = cast<Uint>(0), next_offset = 0);
	match col_count_res {
		core.Result::Ok(v) => { col_count_dec = move v; },
		core.Result::Err(e) => { return core.Result::Err(e); }
	}
	if col_count_dec.next_offset < first_packet.len {
		val metadata_flag_res = lenenc.decode_lenenc_int_at(first_packet, col_count_dec.next_offset);
		var metadata_flag = lenenc.LenEncIntDecoded(value = cast<Uint>(0), next_offset = 0);
		match metadata_flag_res {
			core.Result::Ok(v) => { metadata_flag = move v; },
			core.Result::Err(_) => { return core.Result::Err(_error(errors.TAG_RESULTSET_INVALID_COLUMN_COUNT_PACKET, col_count_dec.next_offset)); }
		}
		if metadata_flag.next_offset != first_packet.len {
			return core.Result::Err(_error(errors.TAG_RESULTSET_INVALID_COLUMN_COUNT_PACKET, col_count_dec.next_offset));
		}
		if metadata_flag.value != cast<Uint>(RESULTSET_METADATA_FOLLOWS_FALSE) and metadata_flag.value != cast<Uint>(RESULTSET_METADATA_FOLLOWS_TRUE) {
			return core.Result::Err(_error(errors.TAG_RESULTSET_INVALID_COLUMN_COUNT_PACKET, col_count_dec.next_offset));
		}
	}
	val column_count = cast<Int>(col_count_dec.value);
	if column_count < 0 {
		return core.Result::Err(_error(errors.TAG_RESULTSET_INVALID_COLUMN_COUNT, 0));
	}
	val row_start = 1 + column_count;
	if packets.len < row_start + 1 {
		return core.Result::Err(_error(errors.TAG_RESULTSET_TRUNCATED_BEFORE_ROWS, packets.len));
	}
	var first_row_idx = row_start;
	if first_row_idx < packets.len {
		val maybe_coldef_terminator = &packets[first_row_idx];
		if _is_eof_terminator_packet(maybe_coldef_terminator) {
			first_row_idx = first_row_idx + 1;
		}
	}
	if packets.len < first_row_idx + 1 {
		return core.Result::Err(_error(errors.TAG_RESULTSET_TRUNCATED_BEFORE_ROWS, packets.len));
	}
	var rows: Array<Array<ResultSetCell>> = [];
	var i = first_row_idx;
	while i < packets.len {
		val payload = &packets[i];
		if _is_eof_terminator_packet(payload) {
			return core.Result::Ok(types.ResultSetDecoded(column_count = col_count_dec.value, rows = move rows));
		}
		match _decode_text_row(payload, column_count) {
			core.Result::Ok(row) => { rows.push(move row); },
			core.Result::Err(e) => { return core.Result::Err(e); }
		}
		i = i + 1;
	}
	return core.Result::Err(_error(errors.TAG_RESULTSET_MISSING_TERMINATOR, packets.len));
}
