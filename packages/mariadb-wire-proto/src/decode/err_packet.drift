module mariadb.wire.proto.decode.err_packet

import std.core as core;
import std.text as text;
import mariadb.wire.proto.errors as errors;
import mariadb.wire.proto.types as types;

export {
	ERR_PACKET_HEADER,
	ERR_SQLSTATE_MARKER,
	decode_err_packet
};

pub const ERR_PACKET_HEADER: Byte = 255;
pub const ERR_SQLSTATE_MARKER: Byte = 35;

fn _error(tag: String, offset: Int) nothrow -> errors.PacketDecodeError {
	return errors.PacketDecodeError(tag = tag, offset = offset);
}

fn _read_u16le(input: &Array<Byte>, offset: Int) nothrow -> Uint {
	return cast<Uint>(input[offset]) + cast<Uint>(input[offset + 1]) * cast<Uint>(256);
}

pub fn decode_err_packet(payload: &Array<Byte>) nothrow -> core.Result<types.ErrPacket, errors.PacketDecodeError> {
	if payload.len < 3 {
		return core.Result::Err(_error(errors.TAG_SHORT_ERR_PACKET, 0));
	}
	if payload[0] != ERR_PACKET_HEADER {
		return core.Result::Err(_error(errors.TAG_INVALID_ERR_HEADER, 0));
	}
	val code = _read_u16le(payload, 1);
	var idx = 3;
	var sql_state = "";
	if idx < payload.len and payload[idx] == ERR_SQLSTATE_MARKER {
		if idx + 6 > payload.len {
			return core.Result::Err(_error(errors.TAG_TRUNCATED_SQL_STATE, idx));
		}
		match text.utf8_from_bytes_range(payload, idx + 1, idx + 6) {
			core.Result::Ok(s) => { sql_state = move s; },
			core.Result::Err(e) => { return core.Result::Err(_error(errors.TAG_ERR_SQLSTATE_UTF8_PREFIX + e.tag, idx + 1 + e.offset)); }
		}
		idx = idx + 6;
	}
	match text.utf8_from_bytes_range(payload, idx, payload.len) {
		core.Result::Ok(message) => {
			return core.Result::Ok(types.ErrPacket(error_code = code, sql_state = move sql_state, message = move message));
		},
		core.Result::Err(e) => {
			return core.Result::Err(_error(errors.TAG_ERR_MESSAGE_UTF8_PREFIX + e.tag, idx + e.offset));
		}
	}
}
