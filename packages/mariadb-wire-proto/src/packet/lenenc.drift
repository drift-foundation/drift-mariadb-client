module mariadb.wire.proto.packet.lenenc

import std.core as core;
import std.text as text;
import mariadb.wire.proto.errors as errors;

export {
	LenEncIntDecoded,
	LenEncBytesDecoded,
	LenEncStringDecoded,
	encode_lenenc_int,
	decode_lenenc_int_at,
	encode_lenenc_string,
	decode_lenenc_bytes_at,
	decode_lenenc_string_at
};

pub struct LenEncIntDecoded {
	pub value: Uint,
	pub next_offset: Int
}

pub struct LenEncBytesDecoded {
	pub value: Array<Byte>,
	pub next_offset: Int
}

pub struct LenEncStringDecoded {
	pub value: String,
	pub next_offset: Int
}

fn _error(tag: String, offset: Int) nothrow -> errors.PacketDecodeError {
	return errors.PacketDecodeError(tag = tag, offset = offset);
}

pub fn encode_lenenc_int(value: Uint) nothrow -> core.Result<Array<Byte>, errors.PacketDecodeError> {
	var out: Array<Byte> = [];
	if value < cast<Uint>(251) {
		out.push(cast<Byte>(value));
		return core.Result::Ok(move out);
	}
	if value <= cast<Uint>(65535) {
		out.push(cast<Byte>(252));
		out.push(cast<Byte>(value % cast<Uint>(256)));
		out.push(cast<Byte>((value / cast<Uint>(256)) % cast<Uint>(256)));
		return core.Result::Ok(move out);
	}
	if value <= cast<Uint>(16777215) {
		out.push(cast<Byte>(253));
		out.push(cast<Byte>(value % cast<Uint>(256)));
		out.push(cast<Byte>((value / cast<Uint>(256)) % cast<Uint>(256)));
		out.push(cast<Byte>((value / cast<Uint>(65536)) % cast<Uint>(256)));
		return core.Result::Ok(move out);
	}
	out.push(cast<Byte>(254));
	var rem = value;
	var i = 0;
	while i < 8 {
		out.push(cast<Byte>(rem % cast<Uint>(256)));
		rem = rem / cast<Uint>(256);
		i = i + 1;
	}
	return core.Result::Ok(move out);
}

pub fn decode_lenenc_int_at(input: &Array<Byte>, offset: Int) nothrow -> core.Result<LenEncIntDecoded, errors.PacketDecodeError> {
	if offset < 0 or offset >= input.len {
		return core.Result::Err(_error("lenenc-out-of-bounds", offset));
	}
	val first = input[offset];
	if first < cast<Byte>(251) {
		return core.Result::Ok(LenEncIntDecoded(value = cast<Uint>(first), next_offset = offset + 1));
	}
	if first == cast<Byte>(251) {
		return core.Result::Err(_error("lenenc-null", offset));
	}
	if first == cast<Byte>(252) {
		if offset + 2 >= input.len {
			return core.Result::Err(_error("lenenc-truncated", offset));
		}
		val v = cast<Uint>(input[offset + 1]) + cast<Uint>(input[offset + 2]) * cast<Uint>(256);
		return core.Result::Ok(LenEncIntDecoded(value = v, next_offset = offset + 3));
	}
	if first == cast<Byte>(253) {
		if offset + 3 >= input.len {
			return core.Result::Err(_error("lenenc-truncated", offset));
		}
		val v = cast<Uint>(input[offset + 1]) + cast<Uint>(input[offset + 2]) * cast<Uint>(256) + cast<Uint>(input[offset + 3]) * cast<Uint>(65536);
		return core.Result::Ok(LenEncIntDecoded(value = v, next_offset = offset + 4));
	}
	if first == cast<Byte>(254) {
		if offset + 8 >= input.len {
			return core.Result::Err(_error("lenenc-truncated", offset));
		}
		var v: Uint = cast<Uint>(0);
		var mul: Uint = cast<Uint>(1);
		var i = 0;
		while i < 8 {
			val b = cast<Uint>(input[offset + 1 + i]);
			v = v + b * mul;
			mul = mul * cast<Uint>(256);
			i = i + 1;
		}
		return core.Result::Ok(LenEncIntDecoded(value = v, next_offset = offset + 9));
	}
	return core.Result::Err(_error("lenenc-invalid-prefix", offset));
}

pub fn encode_lenenc_string(s: &String) nothrow -> core.Result<Array<Byte>, errors.PacketDecodeError> {
	val n = s.byte_length();
	val prefix_res = encode_lenenc_int(cast<Uint>(n));
	var out: Array<Byte> = [];
	match prefix_res {
		Ok(v) => { out = move v; },
		Err(e) => { return core.Result::Err(e); }
	}
	var i = 0;
	while i < n {
		out.push(core.string_byte_at(s, i));
		i = i + 1;
	}
	return core.Result::Ok(move out);
}

pub fn decode_lenenc_bytes_at(input: &Array<Byte>, offset: Int) nothrow -> core.Result<LenEncBytesDecoded, errors.PacketDecodeError> {
	val decoded_res = decode_lenenc_int_at(input, offset);
	var decoded = LenEncIntDecoded(value = cast<Uint>(0), next_offset = 0);
	match decoded_res {
		Ok(v) => { decoded = move v; },
		Err(e) => { return core.Result::Err(e); }
	}
	val str_len = cast<Int>(decoded.value);
	if str_len < 0 {
		return core.Result::Err(_error("lenenc-invalid-length", offset));
	}
	if decoded.next_offset + str_len > input.len {
		return core.Result::Err(_error("lenenc-truncated", decoded.next_offset));
	}
	var out: Array<Byte> = [];
	var i = 0;
	while i < str_len {
		out.push(input[decoded.next_offset + i]);
		i = i + 1;
	}
	return core.Result::Ok(LenEncBytesDecoded(value = move out, next_offset = decoded.next_offset + str_len));
}

pub fn decode_lenenc_string_at(input: &Array<Byte>, offset: Int) nothrow -> core.Result<LenEncStringDecoded, errors.PacketDecodeError> {
	val bytes_res = decode_lenenc_bytes_at(input, offset);
	var empty: Array<Byte> = [];
	var bytes = LenEncBytesDecoded(value = move empty, next_offset = 0);
	match bytes_res {
		Ok(v) => { bytes = move v; },
		Err(e) => { return core.Result::Err(e); }
	}
	val raw: &Array<Byte> = &bytes.value;
	val utf8_res = text.utf8_from_bytes(raw);
	match utf8_res {
		core.Result::Ok(s) => {
			return core.Result::Ok(LenEncStringDecoded(value = move s, next_offset = bytes.next_offset));
		},
		core.Result::Err(e) => {
			return core.Result::Err(_error("utf8-" + e.tag, offset + e.offset));
		}
	}
}
